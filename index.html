<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" href="./mainStyles.css" type="text/css">
    <title>Angular things</title>
</head>
<body>
    <article>
        <h1>Selector prefix</h1>
        <p>Selector prefix is what will be written before the name of our component. Prefix are useful to track where the components is used when debugging for example</p>
        <p>Below is a screenshot where we can see the default app prefix</p>
        <img src="./images/image201.PNG" alt="prefix">
        <p>Of course we can change it to something else if we want. In the tslint.json file we can edit it. On the screenshot is an example</p>
        <img src="./images/image202.PNG" alt="prefixSource">
        <p>If we change it in the .json file it will automatically change in all the components.</p>
        <p>Something important if we want our new components to also use the same prefix we have to also edit it in the angular.json file</p>
        <img src="./images/image203.PNG" alt="prefixAngularJson">
        <p class="tags">Tags: selector tslint.json angular.json prefix</p>
    </article>
    

    <article>
        <h1>Installing bootstrap</h1>
        <p>To install bootstrap in the terminal type "npm install --save bootstrap"</p>
        <img src="./images/image50.PNG" alt="intsallBootstrap">
        <p>Only installing it will not do the whole work, we also have to tell Angular about its existance. We can do that by updating our angular.json file</p>
        <img src="./images/image51.PNG" alt="angularJSONupdate">
        <p class="tags">Tags: angular.json bootstrap</p>
    </article>

    <article>
        <h1>Two-way data binding</h1>
        <p>The two-way data binding is when the view and the data source share information simultaneously. It is done by putting our variable in square and round brackets.</p>
        <img src="./images/image100.PNG" alt="twoWayDataBinding">
        <p>In the data source the shared variable is class property</p>
        <img src="./images/image101.PNG" alt="twoWWaybinding">
        <p>In this where we are using input element if we type in it the result in p element is changed simultaneously</p>
        <img src="./images/image103.PNG" alt="2wayDatabindBrowser">
        <p class="tags">Tags: [(ngModel)]</p>
    </article>

    <article>
        <h1>Data binding from data source to view with double curly brackets</h1>
        <p>If in the class we have variable holding some content, we can use that content with double curly braces.</p>
        <p>Below is a screenshot which shows the variable <span>city</span> with value Sofia</p>
        <img src="./images/image1.PNG" alt="string interpolation">
        <p>And below in the screenshot we can see how to use that variable in the html template. To do that we need to wrap the variable in curly braces.</p>
        <img src="./images/image2.PNG" alt="string interpolation">
        <p>Below we can see the result in the browser</p>
        <img src="./images/image3.PNG" alt="string interpolation">
        <p class="tags">Tags: {{xxx}}</p>
    </article>
   
    <article>
        <h1>Data binding from data source to view with square brackets</h1>
        <p>From the class/data source we can provide data to the html file by wrapping html property in square brackets</p>
        <img src="./images/image301.PNG" alt="dataBinding">
        <p>And this is how we wrap the html attribute. In the below example we give the value attribute data from our component class.</p>
        <img src="./images/image302.PNG" alt="viewDataBinding">
        <p>In the double quotes is the variable from the data source which we will assign to the desired property of the html tag.</p>
        <p>And here is the result</p>
        <img src="./images/image303.PNG" alt="dataBinding">
        <p class="tags">Tags: [xxx]</p>
    </article>
   
    <article>
        <h1>Data binding from view to data source with round brackets</h1>
        <p>We can get data from the template view and use the data in the data source</p>
        <img src="./images/image400.PNG" alt="viewSource">
        <p>With the '#' symbol and then our custom name we can get reference to the html element and then with that reference to use valid html property. The keyup in the example is valid html event. Note that we need to use round brackets when we want to get data from the view. And in the double quotes we are using method from the data source class and providing him the property value which contains the written value in the input.</p>
        <img src="./images/image401.PNG" alt="dataSource">
        <p>Our handler function is method of the class which will get whatever we provide.</p>
        <img src="./images/image402.PNG" alt="broswerView">
        <p>More on #reference, they can be used on any html element and we name them the way we want. The reference holds the html element with all its properties. We can use the reference anywhere in the component html/template but only in the template and not in the ts file for example.</p>
        <p class="tags">Tags: (click) (xxx) #xxx reference</p>
    </article>
    
    <article>
        <h1>Element reference and ViewChild</h1>
        <p>There is many ways to obtain data from the view and on of them is with ViewChild on referenced element. First in the view we have to get reference to the element we want to use.</p>
        <img src="./images/image450.PNG" alt="viewChild">
        <p>In the data source we will use the ViewChild decorator and will giv him the reference name. After the result will be ElementRef we can specify that. Then we will in this example just show the value but we need to use the nativeElement on the reference because the element we are accessing is in the DOM.</p>
        <p>Note that if you are working with ViewChild you will maybe want to use it in the ngAfterViewInit lifecycle hook. Because the first time we will have access to the refferenced element will be after the view is created</p>
        <img src="./images/image451.PNG" alt="viewChild">
        <p>Note that it is not recommended to set values from the nativeElement, use other types of binding if you want to do that. In general it is not good practice to directly set values on native elements</p>
        <p class="tags">Tags: #xxx reference @ViewChild('xxx') ElementRef nativeElement ngAfterViewInit</p>
    </article>
    
    <article>
        <h1>Content between component tags</h1>
        <p>Usually everything between component tag is ignored by Angular, but sometimes we need to use that content. In the below example the paragraph between the child tags we will be ignored and we can show it in the child component with ng-content tag</p>
        <img src="./images/image470.PNG" alt="ngContent">
        <p>We have to place ng-content tag in the child view to show everything between the child component tags</p>
        <img src="./images/image471.PNG" alt="ngContent">
        <p>We can now see we have bothe paragraphs displayed</p>
        <img src="./images/image472.PNG" alt="ngContent">
        <p class="tags">Tags: ng-content</p>
    </article>

    <article>
        <h1>Using if statement and ng class</h1>
        <p>If we have the following array of objects</p>
        <img src="./images/image700.PNG" alt="listobject">
        <p>With *ngIf and [ngClass] we can manage the behaviour of the elements. With *ngIf we can choose what to show or not. And [ngClass] we can set class property to html element based on some condition.</p>
        <img src="./images/image701.PNG" alt="viewConditions">
        <p>This is how our css looks like</p>
        <img src="./images/image702.PNG" alt="styles">
        <p>And we will get the following result</p>
        <img src="./images/image703.PNG" alt="displayConditions">
        <p class="tags">Tags: *ngIf ngClass</p>
    </article>
   
    <article>
        <h1>Using if else statement</h1>
        <p>We can build if else in the following way, but lets first set some class properties to use for the example</p>
        <img src="./images/image750.PNG" alt="ngIfElse">
        <p>So in this case if the variable is set to true we will see our movie title. But if its not the else will use the reference we have made to another text wrapped in ng-template</p>
        <img src="./images/image751.PNG" alt="ngIfElse">
        <p>And after our variable is set to true we will see the movie title</p>
        <img src="./images/image752.PNG" alt="ngIfElse">
        <p class="tags">Tags: *ngIf else ng-template</p>
    </article>
    
    <article>
        <h1>Using for loop in Angular</h1>
        <p>It is used by typing *ngFor. In this example we have an array of objects in the data source and for each of them we will provide them to the view.</p>
        <img src="./images/image500.PNG" alt="users">
        <p>Here we will use it with double curly brackets which are usually used for representing string values</p>
        <img src="./images/image501.PNG" alt="forLoop">
        <p>And this is the result we will get</p>
        <img src="./images/image502.PNG" alt="display">
        <p class="tags">Tags: *ngFor</p>
    </article>
    
    <article>
        <h1>Providing data from parent to child component</h1>
        <p>We can provide data from the parent with square brackets and get the data in the child component with the @Input() decorator. In the parent component we have the following array of objects:</p>
        <img src="./images/image800.PNG" alt="dataObject">
        <p>Now with for loop we will call the child component employee and provide it with each user. In the square brackets is how the variable will be called in the child component. Remember that if you use as a variable valid html attribute we will bind to it our data, because with square brackets we can bind and set values to valid html attributes.</p>
        <img src="./images/image801.PNG" alt="parentView">
        <p>Now in the child component data source we will use the @Input() decorator and give him the variable employer which is in the square brackets in the parent view.</p>
        <img src="./images/image802.PNG" alt="childDataSource">
        <p>And in the child view we will only display the name property from the provided object from the array</p>
        <img src="./images/image803.PNG" alt="childView">
        <p>And this will be the result we will get in the browser</p>
        <img src="./images/image804.PNG" alt="display">
        <p>The Input decorator can also takes string parameter which is known as alias for renaming the property. For example if in the parent view in square brackets we put for example [examp] then in the alias we have to do it this way @Input('examp') myOwnName; In other words we provide examp property and in the alias we write examp but if we want in the child component to use it with different name we can set whatever we want after the decorator.</p>
        <p class="tags">Tags: @Input() [xxx]</p>
    </article>
    
    <article>
        <h1>Event emmiter</h1>
        <p>Event emmiter are very similar to events like click and the rest. They are usefull to provide data from child component to parent component. To achieve that in our parent component first we need to create function which will receive data</p>
        <img src="./images/image900.PNG" alt="emmiterParent">
        <p>Then in the parent view we need to create our custom emmiter which look like the original events. On it we will assign the function from the parent data source which will obtain the data. Note that it is important to use the dollar sign before the parameter name.</p>
        <img src="./images/image901.PNG" alt="emitterParentview">
        <p>Now in the child data source we need to do the set up. First we have to use the @Output() decorator so we can provide data outside the component. The decorator will be for the name of our custom event. Then we need to make another class method which will be the function which will get the data from the child view and inside its body we will use our custom emmiter to output the data.</p>
        <img src="./images/image902.PNG" alt="emmiterClassChild">
        <p>And now in the child view we can decide how to get data and what to get. In this case we will get data with click event and provide it to the child data source</p>
        <img src="./images/image903.PNG" alt="emmiterViewChild">
        <p>The Input decorator can also takes string parameter which is known as alias for renaming the property. For example if in the parent view in round brackets we put for example (examp) then in the alias we have to do it this way @Output('examp') myOwnName; In other words we provide examp property and in the alias we write examp but if we want in the parent component to use it with different name we can set whatever we want after the decorator.</p>
        <p class="tags">Tags: @Output() EventEmitter() [xxx] (xxx)</p>
    </article>
    
    <article>
        <h1>Lifycycle hooks</h1>
        <p>ngOnChanges -> it is called once property with decorator @Input() is changed</p>
        <p>ngOnInit -> it is called on initialization of the component and called after the constructor</p>
        <p>ngDoCheck -> it is used multiple times after any change during every change detection run. It is executed after any change on the view or data source</p>
        <p>ngAfterContentInit -> called after ng-content has been projected into view</p>
        <p class="tags">Tags: ngOnChanges ngOnInit ngDoCheck ngAfterContentInit</p>
    </article>

    <article>
        <h1>Creating our own directive</h1>
        <p>We can create our own directive with the CLI like this "ng g d your-name". By creating directive with the ng/cli our directive will be automatically added to the ngModule so angular can know about its existance</p>
        <img src="./images/image920.PNG" alt="customDirective">
        <p>Our directive has selector which we will use on the elements which we want to apply this directive. Using Renderer2 here is important because if we are working only in browser and know what kind of DOM we will use then we dont really need Renderer2, but on other devices, where the DOM is different our directive will still work. setStyle is just an example here and all settings of the directive, of course we can use directives in many ways.</p>
        <p>Note that in the constructor we can get directly refference to the element on which the directive is applied. This is because our directive is on that element.</p>
        <img src="./images/image921.PNG" alt="customDirective">
        <p>This is how we use it in our view</p>
        <img src="./images/image922.PNG" alt="customDirective">
        <p>And now in the broswer we can see that our paragraph is in green color</p>
        <img src="./images/image923.PNG" alt="customDirective">
        <p class="tags">Tags: directive Renderer2</p>
    </article>
    
    <article>
        <h1>Listening for events with our custom behaviour</h1>
        <p>In the directives we can define listener for some kind of event and define what behaviour we want to achieve. We do this by using @HostListener</p>
        <img src="./images/image930.PNG" alt="HostListener">
        <p>We can set our custom directive to an element like this</p>
        <img src="./images/image931.PNG" alt="HostListener">
        <p>And the result on mouse over in this example will be to set orange background</p>
        <img src="./images/image932.PNG" alt="HostListener">
        <p class="tags">Tags: directive Renderer2 @HostListener Event</p>
    </article>
    
    <article>
        <h1>Basics of routing</h1>
        <p>To have some routing we need to define them as array of objects of type Routes. Then to use that array for routing we need to give it to the RouterModule. forRoot means we will use this routing for our main module</p>
        <img src="./images/image940.PNG" alt="basicRouting">
        <p>In the our view we will have the following items. RouterLinkActive is to set some custom by us class for the current route, and active options attribute to match only '/' because that is usually contained in the other routes and respectively matched by them</p>
        <img src="./images/image941.PNG" alt="basicRoutingView">
        <p>To set some styling for our current route here is some example</p>
        <img src="./images/image942.PNG" alt="basicRoutingViewStyle">
        <p>And this is what we will see in the broswer</p>
        <img src="./images/image943.PNG" alt="basicRoutingBrowser">
        <p class="tags">Tags: Routes RouterModule path forRoot routerLink routerLinkActive routerLinkActiveOptions router-outlet</p>
    </article>
    
    <article>
        <h1>Navigate with some predefined logic</h1>
        <p>If we want to change the route and move somewhere in the application based on some user action like click we can do it this way, in this example it will be by button click</p>
        <img src="./images/image950.PNG" alt="navigation">
        <p>So with button click from the Contacts component we want to switch to About component</p>
        <img src="./images/image951.PNG" alt="navigate">
        <p class="tags">Tags: Router navigate</p>
    </article>
    
    <article>
        <h1>Use variable router params</h1>
        <p>If we need to take the params directly from the url we can do the following way</p>
        <img src="./images/image970.PNG" alt="routerParams">
        <p>In the Contacts componentwe will have anchor tag which will open the contact component with url /contact/123/maria</p>
        <img src="./images/image971.PNG" alt="routerParams">
        <p>Now in the contact component we will get the params from the url. Something very important is that snapshot takes the url in the component creation and if we are changing the url from inside the component the snapshot will not track the changes and params will not change. To fix that in case we need we need to know that ActivatedRoute is observable and we can subscribe to it so anychanges coming from inside the component will update the params. Check the secondary screenshot to see how it works. Also in this case when working with routes Angular will unsubscribe automatically for us in this case</p>
        <img src="./images/image972.PNG" alt="routerParams">
        <img src="./images/image975.PNG" alt="routerParams">
        <p>And we will display them in the contact component view</p>
        <img src="./images/image973.PNG" alt="routerParams">
        <p>And this will be the result in the browser</p>
        <img src="./images/image974.PNG" alt="routerParams">
        <p class="tags">Tags: path routerLink ActivatedRoute</p>
    </article>
    
    <article>
        <h1>Component driven form the basics</h1>
        <p>To work with forms first we need to import in our module file the FormsModule which is required to provide us with all the forms directives and functionality.</p>
        <img src="./images/image1000.PNG" alt="componentForms">
        <p>Now in our view in the form element we first have to get reference to it which is done with the # symbol and to assign to it the ngForm directive so our reference will know it is a form and will be able to manage the form. Then for every element like input etc. we need to put the ngModel attribute, so the element can become part of the ngForm. Also it is important to give every input a name attribute.</p>
        <p>The pre tag is for debug purposes for us to easier check and preview the ngForm. We can see the result in a json object</p>
        <img src="./images/image1001.PNG" alt="formView">
        <p>And our result in the browser will look like this</p>
        <img src="./images/image1002.PNG" alt="browserFormView">
        <p class="tags">Tags: FormsModule ngForm ngModel</p>
    </article>
    
    <article>
        <h1>Submit Component driven form</h1>
        <p>To submit the data we will use submit event and give the function our ngForm as parameter</p>
        <img src="./images/image1100.PNG" alt="submitForm">
        <p>The function in our data source will receive the ngForm and console.log it</p>
        <img src="./images/image1101.PNG" alt="formDataSource">
        <p>In the browser console we can see the whole ngForm object and inspect whatever we would like to use. In most cases controls property is what we need, because it holds information about our html elements.</p>
        <img src="./images/image1102.PNG" alt="browserFormView">
        <p class="tags">Tags: ngForm ngModel |json</p>
    </article>
    
    <article>
        <h1>Grouping elements in common wrapper</h1>
        <p>Often we will need to make connection between different inputs for example password and confirmPassword input where we want one of the inputs to know about the other. In this case we can use common wrapper for both of them. To do that we need to use ngModelGroup</p>
        <img src="./images/image1200.PNG" alt="group">
        <p>In the browser now we can see the inputs with passwords are wrrapped in the as we named secrets object property which is object of the nested elements. This way we can use them combined</p>
        <img src="./images/image1201.PNG" alt="groupObjectBrowserView">
        <p class="tags">Tags: ngModelGroup</p>
    </article>

    <article>
        <h1>Creating and using custom Pipe</h1>
        <p>We can generate new pipe with the cli and after created it should be automatically registered in the module file</p>
        <img src="./images/image1500.PNG" alt="pipeModulefile">
        <p>Out custom Pipe should look like this. The name property in the decorator function is how we will access this pipe in the html file. In the class the transform function will handle the logic of the pipe.</p>
        <p>Something important, note the pure property in the decorator. By default pipes are pure: true. That property is for optimizations if once the data for the pipe was checked not to be checked again if the property is true and if the data is of referrence type. The data will be checked again only if the reference was changed. For that reason we have button onclick which will concat where cancat will change the reference of the object posts. For example push to array will not change the reference of the array and with pure:true the pipe will not update the data</p> 
        <img src="./images/image1501.PNG" alt="pipeFile">
        <p>Below is just how the data looks like and the example of what would happen if we use concat or push</p>
        <img src="./images/image1502.PNG" alt="pipeDataSource">
        <p>In the html file we will use the pipe on the posts provided to the pipe and we will transform the posts object to counter with the help of the pipe. Basically we tell what to transform, in this case the posts and how which is the pipe. The double dots is how we provide parameters to the pipe in case we want to provide some parameters like in this case</p>
        <img src="./images/image1503.PNG" alt="pipeInhtml">
        <p>And we will get the following result in the browser</p>
        <img src="./images/image1504.PNG" alt="pipeInBrowser">
        <p>We can also use multiple pipes by chaining them, where they will be applied one after another</p>
        <p class="tags">Tags: Pipe PipeTransform pure transform |xxx</p>
    </article>
    
    <article>
        <h1>View encapsulation</h1>
        <p>Every component has encapsulation view to make components styling unique by adding additional attributes, in order to make styling for example for paragraph from one component to not get mixed with paragraph stylings from another component. The default value for ViewEncapsulation is Emulated. We can change it this way:</p>
        <img src="./images/image1401.PNG" alt="viewEncapsulation">
        <p class="tags">Tags: encapsulation ViewEncapsulation</p>
    </article>

    <article>
        <h1>Ngx Toastr</h1>
        <p>First run the command "npm install ngx-toastr --save" in the terminal to install toastr. If done correctly you should have it in the dependencies in the package.json file.</p>
        <img src="./images/image1520.PNG" alt="toastr-install">
        <p>Next thing is to register it in the angular.json file in the styles</p>
        <img src="./images/image1521.PNG" alt="toastr-install">
        <p>Now we need to inform Angular about the modules. Note that Toastr depends on BrowserAnimationsModule which comes from angular.</p>
        <img src="./images/image1522.PNG" alt="toastr-modules">
        <p>And here is how we use the toastr</p>
        <img src="./images/image1523.PNG" alt="toastrInterceptor">
        <p class="tags">Tags: toastr interceptor</p>
    </article>

    <article>
        <h1>Interceptor example</h1>
        <p>Interceptors are good to make something with the request or response.For example using toastr or attaching some additional headers. In this example we will add additional header extending our request with existing user</p>
        <img src="./images/image1550.PNG" alt="interceptor-example">
        <p>Here is how we let angular know about the interceptor.</p>
        <img src="./images/image1551.PNG" alt="interceptor-adding">
        <p class="tags">Tags: interceptor HttpInterceptor HttpRequest HttpHandler HttpEvent setHeaders</p>
    </article>
</body>
</html>